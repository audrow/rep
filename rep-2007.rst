REP: 2007
Title: Type Masquerading
Author: Audrow Nash <audrow@openrobotics.org>
Status: Active
Type: Standard
Content-Type: text/x-rst
Created: 28-Jan-2020
Post-History: 28-Jan-2020


Abstract
========

  A short (~200 word) description of the technical issue being addressed.

This REP suggests a new feature for ROS 2's C++ client library that makes it easier to convert between ROS 2 interfaces and common C++ data structures, such as ``std::string`` and ``cv::Mat``.


Motivation
==========

  The motivation is critical for REPs that want to change the ROS APIs. It should clearly explain why the existing API specification is inadequate to address the problem that the REP solves. REP submissions without sufficient motivation may be rejected outright.

The primary reason for this change is to improve the developer's experience working with ROS 2.
Currently, a developer often has to write code to convert a ROS interface into another data structure for use.
This can be trivial, in the case accessing the ``data`` field in ``std_msgs::msg::String``;
or more involved such when converting OpenCV's ``cv::Map`` to ROS's ``sensor_msgs/msg/Image`` type (`here <https://github.com/ros2/demos/blob/11e00ecf7eec25320f950227531119940496d615/image_tools/src/cam2image.cpp#L277-L291>`_).
Such conversions are additional work for the programmer and are potential sources of errors.
This work seeks to provide a 

Specification
=============

  The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current ROS client libraries, if applicable (roscpp, rospy, roslisp, etc...).

While the term of this REP is still selected, the general structure can be thought of as follows, using ``TypeMasquerade`` in this case.

  template<class From, class To>
  struct TypeMapping
  {
    // This is where the conversion would occur
  };

  template<class From>
  struct TypeMasquerade {
    template<class To>
    using as = TypeMapping<From, To>;
  };

Where there are four different tiers of how type masquerading could be expressed.

The most explicit, could look like this::

  using MsgT = rclcpp::TypeMasquerade<std_msgs::msg::String>::as<std::string>;
  rclcpp::Publisher<MsgT>::SharedPtr publisher_;

You would use this if you want it to be clear what is happening (maybe examples or depending on the preferences of the developer), or you might use it when `std::string` could map to more than one ROS type and you need to select which one to use.

We could have a short form of this that takes two arguments::

  rclcpp::Publisher<TypeMapping<std_msgs::msg::String, std::string>>::SharedPtr publisher_;

Or this, but it might be prohibitively complicated to implement since there are multiple template arguments already for Publisher/Subscription::

  rclcpp::Publisher<std_msgs::msg::String, std::string>::SharedPtr publisher_;

Or you can be implicit::

  rclcpp::Publisher<std::string>::SharedPtr publisher_;

If ``std::string`` has multiple types it could represent then this has to error.


Rationale
=========

  The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages.

  The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.

Putting it in ``rclcpp``
------------------------

It is thought that this should be put in the C++ client library for the following reasons:

* Take advantage of C++'s templating system

Picking a term
---------------

Goals
"""""

High priority:
* Clearly communicate the that one type of term
* Clearly communicate the order of the ROS and C++ arguments

Low priority:
* The C++ type should be on the left, so it is seen first
* The order of the arguments shouldn't change in the two argument or one argument form

Candidates
""""""""""

"Masquerade" and "Facade" are the two terms that have been discussed at length. Some pros and cons for these terms are as follows:

+------------+--------------------------------------------------------------+--------------------------------------------+
| **Term**   | **Pros**                                                     | **Cons**                                   |
+------------+--------------------------------------------------------------+--------------------------------------------+
| Masquerade | * Seems to be a common computer science concept,             | * An uncommon word that may be hard for    |
|            |   for example <IP Masquerading in the Linux kernel           |   non-English and non-French speakers      |
|            |   <http://linuxdocs.org/HOWTOs/IP-Masquerade-HOWTO-2.html>`_ |                                            |
|            | * It is a verb, which perhaps makes it easier to discuss     |                                            |
+------------+--------------------------------------------------------------+--------------------------------------------+
| Facade     | * Seems to be a common programming concept for extending     | * Isn't a verb, so perhaps this will make  |
|            |   object oriented behavior [4]_                              |   it harder to talk about in discussions   |
|            | * Seems to be in the public vernacular                       |                                            |
|            | * More correct in an object oriented sense                   |                                            |
+------------+--------------------------------------------------------------+--------------------------------------------+

We can also consider the anticipated usage for each of these terms:

+------------+----------------------------------------------------------+
| **Term**   | **Usage**                                                |
+------------+----------------------------------------------------------+
| Masquerade | ::                                                       |
|            |                                                          |
|            |   Masquerade<std_msgs::msg::String>::as<std::string>     |
|            |                                                          |
|            | or                                                       |
|            |                                                          |
|            | ::                                                       |
|            |                                                          |
|            |   Masquerade<std::string>::as<std_msgs::msg::String>     |
+------------+----------------------------------------------------------+
| Facade     | ::                                                       |
|            |                                                          |
|            |   Facade<std::string>::instead_of<std_msgs::msg::String> |
+------------+----------------------------------------------------------+

A major disadvantage of "Masquerade" is that it is not clear which of the two usages is more correct.
Given a different perspective, both make sense.
This confusion may result in frustration on the part of the ROS 2 developer:
* frequently having to refer back to documentation
* possibly opaque error messages

While "Facade" does seem to be clearerd in terms of arguments, it has been pointed out the ``::instead_of`` syntax doesn't read well.
In addition, the "Facade pattern" [4]_ seems to be more about simplifying an interface, where as in our case, we are proposing to convert one data type to another behind the scenes.


Alternative choices
"""""""""""""""""""

Other possible suggestions (ranked by Audrow's opinion, with best at the top):
* ``TypeAdapter<CppType>::to<RosType>``, follows Adapter pattern [6]_ - also most consistent with [3]_
* ``TypeWrapper<CppType>::to<RosType>``
* ``TypeMap<CppType>::to<RosType>``
* ``TypeUse<CppType>::instead_of<RosType>``
* ``TypeAccept<CppType>::as<RosType>``
* ``TypeConvert<RosType>::to<CppType>``

Suggested but discarded
* Disguise: Discarded in favor of "Facade"
* Decorate: Refers to the decorator pattern, which is not quite what we're doing here as our operations will occur at compile time, not run-time
* Mask: Overloaded as a computer science term [5]_

Prepending the word "Type"
""""""""""""""""""""""""""

Most of the terms being considered refer to a general design pattern and, thus, may be used in other ROS features.
To reduce ambiguity, prefixing the term with "Type" would make its usage clearer and help avoid name collisions.


Backwards Compatibility
=======================

  All REPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The REP must explain how the author proposes to deal with these incompatibilities. REP submissions without a sufficient backwards compatibility treatise may be rejected outright.


Reference Implementation
========================

  The reference implementation must be completed before any REP is given status "Final", but it need not be completed before the REP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code.

  The final implementation must include test code and documentation.

  An example usage of references [1]_.


References
==========

.. [1] REP 1, REP Purpose and Guidelines, Warsaw, Hylton
   (https://ros.org/reps/rep-0001.html)
.. [2] Masquerade, Merriam-Webster
   (https://www.merriam-webster.com/dictionary/masquerade)
.. [3] Adapting C++ Types
   (http://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes#Adapting_C.2B-.2B-_Types)
.. [4] Facade Pattern
   (https://en.wikipedia.org/wiki/Facade_pattern)
.. [5] Masking (computing)
   (https://en.wikipedia.org/wiki/Mask_(computing))
.. [6] Adapter pattern
   (https://en.wikipedia.org/wiki/Adapter_pattern)

Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
